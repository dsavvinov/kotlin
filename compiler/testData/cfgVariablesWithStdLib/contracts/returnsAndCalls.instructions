== callsAndInverts ==
fun callsAndInverts(b: Boolean, block: () -> Unit): Boolean {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
        returns(true) implies (!b)
        returns(false) implies b
    }

    block()
    return !b
}
---------------------
L0:
  1 <START>                                                                                                                                           INIT: in: {} out: {}
    v(b: Boolean)                                                                                                                                     INIT: in: {} out: {b=D}
    magic[FAKE_INITIALIZER](b: Boolean) -> <v0>                                                                                                       INIT: in: {b=D} out: {b=D}
    w(b|<v0>)                                                                                                                                         INIT: in: {b=D} out: {b=ID}
    v(block: () -> Unit)                                                                                                                              INIT: in: {b=ID} out: {b=ID, block=D}
    magic[FAKE_INITIALIZER](block: () -> Unit) -> <v1>                                                                                                INIT: in: {b=ID, block=D} out: {b=ID, block=D}
    w(block|<v1>)                                                                                                                                     INIT: in: {b=ID, block=D} out: {b=ID, block=ID}
  2 mark({ contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b } block() return !b })     INIT: in: {b=ID, block=ID} out: {b=ID, block=ID}
    mark({ callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b })
    jmp?(L2)
    d({ callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b })                                       INIT: in: {b=I, block=I} out: {b=I, block=I}        USE: in: {EXACTLY_ONCE=READ, b=READ, block=READ} out: {EXACTLY_ONCE=READ, b=READ, block=READ}
L2 [after local declaration]:
    r({ callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b }) -> <v2>                               INIT: in: {b=ID, block=ID} out: {b=ID, block=ID}
    mark(contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b })
    call(contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b }, contract|<v2>) -> <v3>                                                        USE: in: {b=READ, block=READ} out: {b=READ, block=READ}
    r(block) -> <v4>                                                                                                                                                                                      USE: in: {b=READ} out: {b=READ, block=READ}
    mark(block())
    call(block(), invoke|<v4>) -> <v5>                                                                                                                                                                    USE: in: {b=READ} out: {b=READ}
    r(b) -> <v6>                                                                                                                                                                                          USE: in: {} out: {b=READ}
    mark(!b)
    call(!b, not|<v6>) -> <v7>
    ret(*|<v7>) L1
L1:
  1 <END>
error:
    <ERROR>                                                                                                                                           INIT: in: {} out: {}
sink:
    <SINK>                                                                                                                                            INIT: in: {b=I?, block=I?} out: {b=I?, block=I?}    USE: in: {} out: {}
=====================
== anonymous_0 ==
{
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
        returns(true) implies (!b)
        returns(false) implies b
    }
---------------------
L3:
  3 <START>                                                                                                       INIT: in: {b=ID, block=ID} out: {b=ID, block=ID}
  4 mark(callsInPlace(block, InvocationKind.EXACTLY_ONCE) returns(true) implies (!b) returns(false) implies b)
    magic[IMPLICIT_RECEIVER](callsInPlace(block, InvocationKind.EXACTLY_ONCE)) -> <v0>                                                                                USE: in: {EXACTLY_ONCE=READ, b=READ, block=READ} out: {EXACTLY_ONCE=READ, b=READ, block=READ}
    r(block) -> <v1>                                                                                                                                                  USE: in: {EXACTLY_ONCE=READ, b=READ} out: {EXACTLY_ONCE=READ, b=READ, block=READ}
    mark(InvocationKind.EXACTLY_ONCE)                                                                                                                                 USE: in: {EXACTLY_ONCE=READ, b=READ} out: {EXACTLY_ONCE=READ, b=READ}
    r(EXACTLY_ONCE) -> <v2>                                                                                                                                           USE: in: {b=READ} out: {EXACTLY_ONCE=READ, b=READ}
    mark(callsInPlace(block, InvocationKind.EXACTLY_ONCE))
    call(callsInPlace(block, InvocationKind.EXACTLY_ONCE), callsInPlace|<v0>, <v1>, <v2>) -> <v3>
    magic[IMPLICIT_RECEIVER](returns(true)) -> <v4>
    r(true) -> <v5>
    mark(returns(true))
    call(returns(true), returns|<v4>, <v5>) -> <v6>
    mark((!b))
    r(b) -> <v7>
    mark(!b)
    call(!b, not|<v7>) -> <v8>
    mark(returns(true) implies (!b))
    call(returns(true) implies (!b), implies|<v6>, <v8>) -> <v9>
    magic[IMPLICIT_RECEIVER](returns(false)) -> <v10>
    r(false) -> <v11>
    mark(returns(false))
    call(returns(false), returns|<v10>, <v11>) -> <v12>                                                                                                               USE: in: {b=READ} out: {b=READ}
    r(b) -> <v13>                                                                                                                                                     USE: in: {} out: {b=READ}
    mark(returns(false) implies b)
    call(returns(false) implies b, implies|<v12>, <v13>) -> <v14>
L4:
  3 <END>
error:
    <ERROR>                                                                                                       INIT: in: {} out: {}
sink:
    <SINK>                                                                                                        INIT: in: {b=I, block=I} out: {b=I, block=I}        USE: in: {} out: {}
=====================
== smartcastAndInitialization ==
fun smartcastAndInitialization(x: Any?) {
    val y: Int

    if (callsAndInverts(x !is String) { y = 42 }) {
        println(y)
        <!DEBUG_INFO_SMARTCAST!>x<!>.length
    }
    else {
        println(y)
        x.<!UNRESOLVED_REFERENCE!>length<!>
    }
    println(y)
}
---------------------
L0:
  1 <START>                                                                                                                                                                                     INIT: in: {} out: {}
    v(x: Any?)                                                                                                                                                                                  INIT: in: {} out: {x=D}
    magic[FAKE_INITIALIZER](x: Any?) -> <v0>                                                                                                                                                    INIT: in: {x=D} out: {x=D}
    w(x|<v0>)                                                                                                                                                                                   INIT: in: {x=D} out: {x=ID}                 USE: in: {x=READ} out: {x=READ}
  2 mark({ val y: Int if (callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> } println(y) })    INIT: in: {x=ID} out: {x=ID}
    v(val y: Int)                                                                                                                                                                               INIT: in: {x=ID} out: {x=ID, y=D}
    mark(if (callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> })                              INIT: in: {x=ID, y=D} out: {x=ID, y=D}
    mark(x !is String)
    r(x) -> <v1>
    magic[IS](x !is String|<v1>) -> <v2>
    mark({ y = 42 })
    r({ y = 42 }) -> <v3>
    mark(callsAndInverts(x !is String) { y = 42 })
    call(callsAndInverts(x !is String) { y = 42 }, callsAndInverts|<v2>, <v3>) -> <v4>
L2 [before inlined declaration]:
    inlined({ y = 42 })                                                                                                                                                                         INIT: in: {x=ID, y=ID} out: {x=ID, y=ID}    USE: in: {x=READ, y=WRITTEN_AFTER_READ} out: {x=READ, y=WRITTEN_AFTER_READ}
L3 [after inlined declaration]:
    jf(L6|<v4>)                                                                                                                                                                                                                             USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
  3 mark({ println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length })
    r(y) -> <v5>
    mark(println(y))
    call(println(y), println|<v5>) -> <v6>
    magic[UNRESOLVED_CALL](DEBUG_INFO_SMARTCAST) -> <v7>
    mark(!DEBUG_INFO_SMARTCAST)
    call(!DEBUG_INFO_SMARTCAST, <ERROR FUNCTION>|<v7>) -> <v8>
  2 jmp(L7)                                                                                                                                                                                                                                 USE: in: {y=READ} out: {y=READ}
L6 [else branch]:
  3 mark({ println(y) x.<!UNRESOLVED_REFERENCE!>length<!> })
    r(y) -> <v9>
    mark(println(y))
    call(println(y), println|<v9>) -> <v10>
    mark(x.<)                                                                                                                                                                                                                               USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
    r(x) -> <v11>                                                                                                                                                                                                                           USE: in: {y=READ} out: {x=READ, y=READ}
    magic[UNSUPPORTED_ELEMENT](x.<|<v11>) -> <v12>
L7 ['if' expression result]:
  2 merge(if (callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> }|<v8>, <v12>) -> <v13>                                                    USE: in: {y=READ} out: {y=READ}
    r(y) -> <v14>                                                                                                                                                                                                                           USE: in: {} out: {y=READ}
    mark(println(y))
    call(println(y), println|<v14>) -> <v15>
L1:
  1 <END>                                                                                                                                                                                       INIT: in: {x=ID} out: {x=ID}
error:
    <ERROR>                                                                                                                                                                                     INIT: in: {} out: {}
sink:
    <SINK>                                                                                                                                                                                      INIT: in: {x=I?} out: {x=I?}                USE: in: {} out: {}
=====================
== inlined anonymous_1 ==
{ y = 42 }
---------------------
L4:
  3 <START>          INIT: in: {x=ID, y=D} out: {x=ID, y=D}
  4 mark(y = 42)
    r(42) -> <v0>                                                USE: in: {x=READ, y=WRITTEN_AFTER_READ} out: {x=READ, y=WRITTEN_AFTER_READ}
    w(y|<v0>)        INIT: in: {x=ID, y=D} out: {x=ID, y=ID}     USE: in: {x=READ, y=READ} out: {x=READ, y=WRITTEN_AFTER_READ}
L5:
  3 <END>            INIT: in: {x=ID, y=ID} out: {x=ID, y=ID}    USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
error:
-   <ERROR>
sink:
    <SINK>           INIT: in: {x=ID, y=ID} out: {x=ID, y=ID}    USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
=====================
== inPresenceOfLazy ==
fun inPresenceOfLazy(x: Any?, unknownBoolean: Boolean) {
    val y: Int

    if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) {
        println(y)
        <!DEBUG_INFO_SMARTCAST!>x<!>.length
    }
    else {
        println(y)
        x.<!UNRESOLVED_REFERENCE!>length<!>
    }
    println(y)
}
---------------------
L0:
  1 <START>                                                                                                                                                                                                       INIT: in: {} out: {}
    v(x: Any?)                                                                                                                                                                                                    INIT: in: {} out: {x=D}
    magic[FAKE_INITIALIZER](x: Any?) -> <v0>                                                                                                                                                                      INIT: in: {x=D} out: {x=D}
    w(x|<v0>)                                                                                                                                                                                                     INIT: in: {x=D} out: {x=ID}
    v(unknownBoolean: Boolean)                                                                                                                                                                                    INIT: in: {x=ID} out: {unknownBoolean=D, x=ID}
    magic[FAKE_INITIALIZER](unknownBoolean: Boolean) -> <v1>                                                                                                                                                      INIT: in: {unknownBoolean=D, x=ID} out: {unknownBoolean=D, x=ID}
    w(unknownBoolean|<v1>)                                                                                                                                                                                        INIT: in: {unknownBoolean=D, x=ID} out: {unknownBoolean=ID, x=ID}                   USE: in: {unknownBoolean=READ, x=READ} out: {unknownBoolean=READ, x=READ}
  2 mark({ val y: Int if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> } println(y) })    INIT: in: {unknownBoolean=ID, x=ID} out: {unknownBoolean=ID, x=ID}
    v(val y: Int)                                                                                                                                                                                                 INIT: in: {unknownBoolean=ID, x=ID} out: {unknownBoolean=ID, x=ID, y=D}
    mark(if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> })                              INIT: in: {unknownBoolean=ID, x=ID, y=D} out: {unknownBoolean=ID, x=ID, y=D}        USE: in: {unknownBoolean=READ, x=READ, y=READ} out: {unknownBoolean=READ, x=READ, y=READ}
    r(unknownBoolean) -> <v2>                                                                                                                                                                                                                                                                         USE: in: {x=READ, y=READ} out: {unknownBoolean=READ, x=READ, y=READ}
    jf(L2|<v2>)                                                                                                                                                                                                                                                                                       USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
    mark(x !is String)
    r(x) -> <v3>
    magic[IS](x !is String|<v3>) -> <v4>
    mark({ y = 42 })
    r({ y = 42 }) -> <v5>
    mark(callsAndInverts(x !is String) { y = 42 })
    call(callsAndInverts(x !is String) { y = 42 }, callsAndInverts|<v4>, <v5>) -> <v6>
L3 [before inlined declaration]:
    inlined({ y = 42 })                                                                                                                                                                                           INIT: in: {unknownBoolean=ID, x=ID, y=ID} out: {unknownBoolean=ID, x=ID, y=ID}      USE: in: {x=READ, y=WRITTEN_AFTER_READ} out: {x=READ, y=WRITTEN_AFTER_READ}
L2 [result of boolean operation]:
L4 [after inlined declaration]:
    magic[AND](unknownBoolean && callsAndInverts(x !is String) { y = 42 }|<v2>, <v6>) -> <v7>                                                                                                                     INIT: in: {unknownBoolean=ID, x=ID, y=I?D} out: {unknownBoolean=ID, x=ID, y=I?D}
    jf(L7|<v7>)                                                                                                                                                                                                                                                                                       USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
  3 mark({ println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length })
    r(y) -> <v8>
    mark(println(y))
    call(println(y), println|<v8>) -> <v9>
    magic[UNRESOLVED_CALL](DEBUG_INFO_SMARTCAST) -> <v10>
    mark(!DEBUG_INFO_SMARTCAST)
    call(!DEBUG_INFO_SMARTCAST, <ERROR FUNCTION>|<v10>) -> <v11>
  2 jmp(L8)                                                                                                                                                                                                                                                                                           USE: in: {y=READ} out: {y=READ}
L7 [else branch]:
  3 mark({ println(y) x.<!UNRESOLVED_REFERENCE!>length<!> })
    r(y) -> <v12>
    mark(println(y))
    call(println(y), println|<v12>) -> <v13>
    mark(x.<)                                                                                                                                                                                                                                                                                         USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
    r(x) -> <v14>                                                                                                                                                                                                                                                                                     USE: in: {y=READ} out: {x=READ, y=READ}
    magic[UNSUPPORTED_ELEMENT](x.<|<v14>) -> <v15>
L8 ['if' expression result]:
  2 merge(if (unknownBoolean && callsAndInverts(x !is String) { y = 42 }) { println(y) <!DEBUG_INFO_SMARTCAST!>x<!>.length } else { println(y) x.<!UNRESOLVED_REFERENCE!>length<!> }|<v11>, <v15>) -> <v16>                                                                                           USE: in: {y=READ} out: {y=READ}
    r(y) -> <v17>                                                                                                                                                                                                                                                                                     USE: in: {} out: {y=READ}
    mark(println(y))
    call(println(y), println|<v17>) -> <v18>
L1:
  1 <END>                                                                                                                                                                                                         INIT: in: {unknownBoolean=ID, x=ID} out: {unknownBoolean=ID, x=ID}
error:
    <ERROR>                                                                                                                                                                                                       INIT: in: {} out: {}
sink:
    <SINK>                                                                                                                                                                                                        INIT: in: {unknownBoolean=I?, x=I?} out: {unknownBoolean=I?, x=I?}                  USE: in: {} out: {}
=====================
== inlined anonymous_2 ==
{ y = 42 }
---------------------
L5:
  3 <START>          INIT: in: {unknownBoolean=ID, x=ID, y=D} out: {unknownBoolean=ID, x=ID, y=D}
  4 mark(y = 42)
    r(42) -> <v0>                                                                                      USE: in: {x=READ, y=WRITTEN_AFTER_READ} out: {x=READ, y=WRITTEN_AFTER_READ}
    w(y|<v0>)        INIT: in: {unknownBoolean=ID, x=ID, y=D} out: {unknownBoolean=ID, x=ID, y=ID}     USE: in: {x=READ, y=READ} out: {x=READ, y=WRITTEN_AFTER_READ}
L6:
  3 <END>            INIT: in: {unknownBoolean=ID, x=ID, y=ID} out: {unknownBoolean=ID, x=ID, y=ID}    USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
error:
-   <ERROR>
sink:
    <SINK>           INIT: in: {unknownBoolean=ID, x=ID, y=ID} out: {unknownBoolean=ID, x=ID, y=ID}    USE: in: {x=READ, y=READ} out: {x=READ, y=READ}
=====================
